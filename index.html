<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport"
    content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes, viewport-fit=cover">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=VT323:wght@400&display=swap" rel="stylesheet">
  <title>Practical Wisdom</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      user-select: none;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      -webkit-touch-callout: none;
      -webkit-tap-highlight-color: transparent;
    }

    :root {
      --base-font-size: clamp(12px, 1.8vw, 18px);
      --canvas-bg: #000000;
      --text-primary: #EAEAEA;
      --text-secondary: #BDBDBD;
      --button-bg: rgba(255, 255, 255, 0.08);
      --button-border: rgba(255, 255, 255, 0.3);
    }

    html {
      font-size: var(--base-font-size);
      -webkit-text-size-adjust: 100%;
      -ms-text-size-adjust: 100%;
      scroll-behavior: smooth;
    }

    html,
    body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      touch-action: none;
      position: fixed;
      top: 0;
      left: 0;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    body {
      background: var(--canvas-bg);
      font-family: "VT323", monospace;
      cursor: default;
      margin: 0;
      padding: 0;
      transform: translateZ(0);
      will-change: transform;
    }

    .canvas-container {
      position: relative;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      contain: layout style paint;
    }

    canvas {
      display: block;
      background: var(--canvas-bg);
      cursor: pointer;
      width: 100%;
      height: 100%;
      position: absolute;
      top: 0;
      left: 0;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
      transform: translateZ(0);
      will-change: transform;
      image-rendering: -webkit-optimize-contrast;
      image-rendering: crisp-edges;
    }

    @media (max-width: 320px) {
      :root {
        --base-font-size: 10px;
      }
    }

    @media (max-width: 480px) {
      :root {
        --base-font-size: 12px;
      }
    }

    @media (max-width: 576px) {
      :root {
        --base-font-size: 13px;
      }
    }

    @media (max-width: 768px) {
      :root {
        --base-font-size: 14px;
      }
    }

    @media (max-width: 1024px) {
      :root {
        --base-font-size: 15px;
      }
    }

    @media (max-width: 1280px) {
      :root {
        --base-font-size: 16px;
      }
    }

    @media (min-width: 1440px) {
      :root {
        --base-font-size: 18px;
      }
    }

    @media (max-height: 500px) and (orientation: landscape) {
      :root {
        --base-font-size: 11px;
      }
    }

    @media (max-height: 600px) and (orientation: landscape) {
      :root {
        --base-font-size: 12px;
      }
    }

    .loading-fallback {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: var(--text-primary);
      font-family: "VT323", monospace;
      font-size: 1.5rem;
      text-align: center;
      z-index: 1000;
    }

    .error .loading-fallback {
      display: block;
    }

    @media (-webkit-min-device-pixel-ratio: 2),
    (min-resolution: 192dpi) {
      canvas {
        image-rendering: -webkit-optimize-contrast;
        image-rendering: crisp-edges;
      }
    }

    @supports (container-type: inline-size) {
      .canvas-container {
        container-type: inline-size;
      }
    }
  </style>
</head>

<body>
  <div class="canvas-container">
    <canvas id="canvas"></canvas>
  </div>
  <div class="loading-fallback">Loading Practical Wisdom...</div>

  <script>
    const BREAKPOINTS = {
      xs: 320,
      sm: 480,
      md: 768,
      lg: 1024,
      xl: 1280,
      xxl: 1440
    };

    function getBreakpoint() {
      const width = window.innerWidth;
      if (width < BREAKPOINTS.sm) return 'xs';
      if (width < BREAKPOINTS.md) return 'sm';
      if (width < BREAKPOINTS.lg) return 'md';
      if (width < BREAKPOINTS.xl) return 'lg';
      if (width < BREAKPOINTS.xxl) return 'xl';
      return 'xxl';
    }

    function getViewportInfo() {
      return {
        width: window.innerWidth,
        height: window.innerHeight,
        ratio: window.innerWidth / window.innerHeight,
        isPortrait: window.innerHeight > window.innerWidth,
        isLandscape: window.innerWidth > window.innerHeight
      };
    }

    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d', {
      alpha: false,
      desynchronized: true,
      powerPreference: 'high-performance'
    });

    let devicePixelRatio = Math.min(window.devicePixelRatio || 1, 2);
    let isTouch = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0) || (navigator.msMaxTouchPoints > 0);
    let isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    let isHighDPI = devicePixelRatio > 1;

    const perfStats = {
      frameCount: 0,
      lastFPSCheck: 0,
      currentFPS: 60
    };

    let lastFrameTime = 0;
    const targetFPS = 60;
    const frameInterval = 1000 / targetFPS;

    let animationStartTime = 0;
    let isAnimationComplete = false;
    let starsVisible = false;

    const ANIMATION_DELAYS = {
      stars: isMobile ? 200 : 500,
      title: isMobile ? 600 : 1000,
      subtitle: isMobile ? 1000 : 1800,
      tagline: isMobile ? 1400 : 2400,
      paragraph: isMobile ? 1800 : 3200,
      buttons: isMobile ? 2400 : 4000
    };

    const ANIMATION_DURATIONS = {
      stars: isMobile ? 1000 : 1500,
      title: isMobile ? 800 : 1200,
      subtitle: isMobile ? 500 : 800,
      tagline: isMobile ? 400 : 600,
      paragraph: isMobile ? 600 : 1000,
      buttons: isMobile ? 500 : 800
    };

    function easeOutCubic(t) {
      return 1 - Math.pow(1 - t, 3);
    }

    function easeInOutCubic(t) {
      return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
    }

    function easeOutQuart(t) {
      return 1 - Math.pow(1 - t, 4);
    }

    function getAnimationProgress(startTime, delay, duration) {
      const elapsed = Date.now() - startTime;
      if (elapsed < delay) return 0;
      const progress = Math.min((elapsed - delay) / duration, 1);
      return easeOutQuart(progress);
    }

    function getTitleAnimationProgress(startTime, delay, duration) {
      const elapsed = Date.now() - startTime;
      if (elapsed < delay) return { opacity: 0, y: -30 };
      const progress = Math.min((elapsed - delay) / duration, 1);
      const easedProgress = easeInOutCubic(progress);
      return {
        opacity: easedProgress,
        y: -30 * (1 - easedProgress)
      };
    }

    function getSlideUpProgress(startTime, delay, duration) {
      const elapsed = Date.now() - startTime;
      if (elapsed < delay) return { opacity: 0, y: 20 };
      const progress = Math.min((elapsed - delay) / duration, 1);
      const easedProgress = easeOutCubic(progress);
      return {
        opacity: easedProgress,
        y: 20 * (1 - easedProgress)
      };
    }

    function drawRoundedRect(x, y, width, height, radius) {
      ctx.beginPath();
      ctx.moveTo(x + radius, y);
      ctx.lineTo(x + width - radius, y);
      ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
      ctx.lineTo(x + width, y + height - radius);
      ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
      ctx.lineTo(x + radius, y + height);
      ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
      ctx.lineTo(x, y + radius);
      ctx.quadraticCurveTo(x, y, x + radius, y);
      ctx.closePath();
    }

    function getResponsiveSizes() {
      const breakpoint = getBreakpoint();
      const viewport = getViewportInfo();
      const baseWidth = Math.min(canvas.width, 1920);
      const baseHeight = Math.min(canvas.height, 1080);

      const sizeConfigs = {
        xs: {
          scale: viewport.isPortrait ? 0.35 : 0.40,
          minTitle: 16,
          minText: 10,
          paragraphWidth: Math.min(viewport.width * 0.85, 260)
        },
        sm: {
          scale: viewport.isPortrait ? 0.45 : 0.50,
          minTitle: 18,
          minText: 11,
          paragraphWidth: Math.min(viewport.width * 0.88, 320)
        },
        md: {
          scale: 0.65,
          minTitle: 22,
          minText: 13,
          paragraphWidth: Math.min(viewport.width * 0.90, 500)
        },
        lg: {
          scale: 0.8,
          minTitle: 26,
          minText: 15,
          paragraphWidth: Math.min(viewport.width * 0.85, 700)
        },
        xl: {
          scale: 0.95,
          minTitle: 30,
          minText: 17,
          paragraphWidth: Math.min(viewport.width * 0.80, 900)
        },
        xxl: {
          scale: 1.1,
          minTitle: 34,
          minText: 19,
          paragraphWidth: Math.min(viewport.width * 0.75, 1000)
        }
      };

      const config = sizeConfigs[breakpoint];
      let scaleFactor = Math.min(baseWidth / 1920, baseHeight / 1080) * config.scale;

      if (viewport.ratio > 2.5) {
        scaleFactor *= 0.85;
      }

      if (isHighDPI && !isMobile) {
        scaleFactor *= 1.05;
      }

      const spacingMultiplier = viewport.isPortrait && breakpoint === 'xs' ? 0.8 : 1.0;

      return {
        titleSize: Math.max(Math.min(80 * scaleFactor, viewport.width * 0.12), config.minTitle),
        subtitleSize: Math.max(Math.min(42 * scaleFactor, viewport.width * 0.08), config.minText + 3),
        taglineSize: Math.max(Math.min(32 * scaleFactor, viewport.width * 0.065), config.minText + 1),
        paragraphSize: Math.max(Math.min(24 * scaleFactor, viewport.width * 0.045), config.minText),
        buttonSize: Math.max(Math.min(26 * scaleFactor, viewport.width * 0.05), config.minText),
        buttonHeight: Math.max(40 * scaleFactor, breakpoint === 'xs' ? 28 : 35),
        buttonPadding: Math.max(30 * scaleFactor, breakpoint === 'xs' ? 10 : 15),
        paragraphWidth: config.paragraphWidth,
        spacing: {
          title: (breakpoint === 'xs' ? 0.18 : breakpoint === 'sm' ? 0.20 : 0.25) * spacingMultiplier,
          subtitle: (breakpoint === 'xs' ? 0.10 : breakpoint === 'sm' ? 0.12 : 0.14) * spacingMultiplier,
          tagline: (breakpoint === 'xs' ? 0.05 : breakpoint === 'sm' ? 0.06 : 0.09) * spacingMultiplier,
          paragraph: (breakpoint === 'xs' ? -0.08 : breakpoint === 'sm' ? -0.05 : 0.04) * spacingMultiplier,
          buttons: (breakpoint === 'xs' ? 0.12 : breakpoint === 'sm' ? 0.15 : 0.18) * spacingMultiplier,
          buttonGap: Math.max(baseHeight * 0.08, breakpoint === 'xs' ? 20 : 25)
        },
        breakpoint,
        scaleFactor,
        viewport,
        isSmallScreen: breakpoint === 'xs' || breakpoint === 'sm',
        isVerySmallScreen: breakpoint === 'xs'
      };
    }

    function setupCanvas() {
      const rect = canvas.getBoundingClientRect();
      const dpr = Math.min(devicePixelRatio, isMobile ? 1.5 : 2);

      canvas.width = rect.width * dpr;
      canvas.height = rect.height * dpr;

      canvas.style.width = rect.width + 'px';
      canvas.style.height = rect.height + 'px';

      ctx.scale(dpr, dpr);

      canvas.width = rect.width;
      canvas.height = rect.height;

      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'high';

      initStars();
      draw();
    }

    let resizeTimeout;
    let lastResizeTime = 0;

    function debouncedResize() {
      const now = Date.now();
      if (now - lastResizeTime < 100) return;

      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(() => {
        setupCanvas();
        lastResizeTime = now;
      }, 150);
    }

    window.addEventListener('resize', debouncedResize, { passive: true });
    window.addEventListener('orientationchange', () => {
      setTimeout(setupCanvas, 300);
    });

    let isVisible = true;
    document.addEventListener('visibilitychange', () => {
      isVisible = !document.hidden;
      if (isVisible) {
        lastFrameTime = 0;
      }
    }, { passive: true });

    let stars = [];

    function initStars() {
      const sizes = getResponsiveSizes();
      const breakpoint = sizes.breakpoint;

      const starCounts = {
        xs: 40,
        sm: 60,
        md: 90,
        lg: 120,
        xl: 150,
        xxl: 180
      };

      const numStars = starCounts[breakpoint];
      const baseSize = breakpoint === 'xs' ? 0.8 : breakpoint === 'sm' ? 1.0 : 1.5;
      const sizeVariation = breakpoint === 'xs' ? 0.8 : breakpoint === 'sm' ? 1.0 : 1.8;

      stars = [];
      for (let i = 0; i < numStars; i++) {
        stars.push({
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height,
          size: baseSize + Math.random() * sizeVariation,
          opacity: 0.2 + Math.random() * 0.6,
          twinkleSpeed: 1.2 + Math.random() * 2.8,
          phase: Math.random() * Math.PI * 2,
          initialDelay: Math.random() * 600,
          animationSpeed: 0.6 + Math.random() * 0.8
        });
      }
    }

    const buttons = [
      {
        text: "Take the quiz",
        y: 0,
        width: 0,
        height: 0,
        fontSize: 0,
        isPrimary: true,
        href: "quiz.html"
      },
      {
        text: "GlyphThoughts Website",
        y: 0,
        width: 0,
        height: 0,
        fontSize: 0,
        isPrimary: false,
        href: "https://glyphthoughts.carrd.co"
      }
    ];

    let hoveredButton = -1;
    let time = 0;
    let fontsLoaded = false;

    function loadFonts() {
      return new Promise((resolve) => {
        if (!document.fonts) {
          setTimeout(() => {
            fontsLoaded = true;
            resolve();
          }, 1000);
          return;
        }

        const fontPromises = [
          document.fonts.load('400 16px VT323')
        ];

        Promise.allSettled(fontPromises).then(() => {
          fontsLoaded = true;
          resolve();
        });

        setTimeout(() => {
          if (!fontsLoaded) {
            fontsLoaded = true;
            resolve();
          }
        }, 2000);
      });
    }

    function drawStars() {
      if (!isVisible) return;

      const starsProgress = getAnimationProgress(animationStartTime, ANIMATION_DELAYS.stars, ANIMATION_DURATIONS.stars);
      if (starsProgress <= 0) return;

      ctx.fillStyle = 'white';

      stars.forEach((star) => {
        const starDelay = star.initialDelay * star.animationSpeed;
        const individualProgress = getAnimationProgress(
          animationStartTime + starDelay,
          ANIMATION_DELAYS.stars,
          ANIMATION_DURATIONS.stars * 0.7
        );

        if (individualProgress <= 0) return;

        const twinkle = 0.1 + 0.9 * (0.5 + 0.5 * Math.sin(time * 0.001 * star.twinkleSpeed + star.phase));
        const animatedOpacity = star.opacity * twinkle * individualProgress;
        const animatedSize = star.size * twinkle * individualProgress;

        ctx.globalAlpha = animatedOpacity;
        ctx.beginPath();
        ctx.arc(star.x, star.y, animatedSize, 0, Math.PI * 2);
        ctx.fill();
      });

      ctx.globalAlpha = 1;
    }

    function splitTextIntoLines(text, maxWidth, fontSize) {
      ctx.font = `${fontSize}px VT323, monospace`;

      const words = text.split(' ');
      const lines = [];
      let currentLine = '';

      for (let i = 0; i < words.length; i++) {
        const word = words[i];
        const testLine = currentLine + (currentLine ? ' ' : '') + word;
        const metrics = ctx.measureText(testLine);

        if (metrics.width > maxWidth && currentLine) {
          lines.push(currentLine.trim());
          currentLine = word;
        } else {
          currentLine = testLine;
        }
      }

      if (currentLine) {
        lines.push(currentLine.trim());
      }

      return lines;
    }

    function drawAnimatedText(text, x, y, fontSize, color = '#EAEAEA', align = 'center', maxWidth = null) {
      ctx.font = `${fontSize}px VT323, monospace`;
      ctx.fillStyle = color;
      ctx.textAlign = align;
      ctx.textBaseline = 'middle';

      if (maxWidth) {
        const lines = splitTextIntoLines(text, maxWidth, fontSize);
        const sizes = getResponsiveSizes();
        const lineHeight = fontSize * (sizes.breakpoint === 'xs' ? 1.1 : sizes.breakpoint === 'sm' ? 1.2 : 1.3);
        const startY = y - ((lines.length - 1) * lineHeight) / 2;

        lines.forEach((line, i) => {
          const lineY = startY + i * lineHeight;
          ctx.fillText(line, x, lineY);
        });

        return lines.length * lineHeight;
      } else {
        ctx.fillText(text, x, y);
        return fontSize;
      }
    }

    function drawButton(button, index) {
      const isHovered = hoveredButton === index;
      const centerX = canvas.width / 2;
      const sizes = getResponsiveSizes();

      const buttonProgress = getSlideUpProgress(
        animationStartTime,
        ANIMATION_DELAYS.buttons + (index * 120),
        ANIMATION_DURATIONS.buttons
      );
      if (buttonProgress.opacity <= 0) return;

      const hoverMultiplier = isHovered ? 1.3 : 1.0;
      const baseAlpha = sizes.breakpoint === 'xs' ? 0.06 : sizes.breakpoint === 'sm' ? 0.07 : 0.08;
      const alpha = baseAlpha * hoverMultiplier * buttonProgress.opacity;

      ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
      ctx.strokeStyle = button.isPrimary ?
        `rgba(255, 255, 255, ${0.3 * buttonProgress.opacity})` :
        `rgba(255, 255, 255, ${0.2 * buttonProgress.opacity})`;
      ctx.lineWidth = sizes.breakpoint === 'xs' ? 0.6 : sizes.breakpoint === 'sm' ? 0.8 : 1.0;

      const animatedY = button.y + buttonProgress.y;
      const buttonX = centerX - button.width / 2;
      const buttonY = animatedY - button.height / 2;

      const radius = Math.min(4, button.height * 0.12);
      drawRoundedRect(buttonX, buttonY, button.width, button.height, radius);
      ctx.fill();
      ctx.stroke();

      ctx.globalAlpha = buttonProgress.opacity * (isHovered ? 1.0 : 0.85);
      ctx.fillStyle = isHovered ? '#FFFFFF' : '#EAEAEA';
      ctx.font = `${button.fontSize}px VT323, monospace`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(button.text, centerX, animatedY);
      ctx.globalAlpha = 1;
    }

    function draw() {
      if (!fontsLoaded || !isVisible) return;

      const frameStart = performance.now();

      ctx.fillStyle = '#000000';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      drawStars();

      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      const sizes = getResponsiveSizes();

      const titleAnim = getTitleAnimationProgress(animationStartTime, ANIMATION_DELAYS.title, ANIMATION_DURATIONS.title);
      if (titleAnim.opacity > 0) {
        const titleY = centerY - (canvas.height * sizes.spacing.title) + titleAnim.y;
        ctx.globalAlpha = titleAnim.opacity;
        drawAnimatedText("Practical Wisdom", centerX, titleY, sizes.titleSize, '#EAEAEA');
        ctx.globalAlpha = 1;
      }

      const subtitleAnim = getSlideUpProgress(animationStartTime, ANIMATION_DELAYS.subtitle, ANIMATION_DURATIONS.subtitle);
      if (subtitleAnim.opacity > 0) {
        const subtitleY = centerY - (canvas.height * sizes.spacing.subtitle) + subtitleAnim.y;
        ctx.globalAlpha = subtitleAnim.opacity;
        drawAnimatedText("The Stoic Mindset", centerX, subtitleY, sizes.subtitleSize, '#BDBDBD');
        ctx.globalAlpha = 1;
      }

      const taglineAnim = getSlideUpProgress(animationStartTime, ANIMATION_DELAYS.tagline, ANIMATION_DURATIONS.tagline);
      if (taglineAnim.opacity > 0) {
        const taglineY = centerY - (canvas.height * sizes.spacing.tagline) + taglineAnim.y;
        ctx.globalAlpha = taglineAnim.opacity;
        drawAnimatedText("'Introspection Exercise'", centerX, taglineY, sizes.taglineSize, '#BDBDBD');
        ctx.globalAlpha = 1;
      }

      const paragraphAnim = getSlideUpProgress(animationStartTime, ANIMATION_DELAYS.paragraph, ANIMATION_DURATIONS.paragraph);
      if (paragraphAnim.opacity > 0) {
        const paragraphY = centerY + (canvas.height * sizes.spacing.paragraph) + paragraphAnim.y;
        ctx.globalAlpha = paragraphAnim.opacity;
        const aboutText = "Ten prompt-based questions completed in about 3-5 minutes; no grading and no leaderboardsâ€”only reflection over comparison. The language and tone are shaped by Stoic practice: restraint, judgment, purpose. On completion, an optional certificate acknowledges the identified mindset; it is not a qualification.";
        drawAnimatedText(aboutText, centerX, paragraphY, sizes.paragraphSize, '#FFFFFF', 'center', sizes.paragraphWidth);
        ctx.globalAlpha = 1;
      }

      const buttonStartY = centerY + (canvas.height * sizes.spacing.buttons);
      buttons.forEach((button, index) => {
        button.fontSize = sizes.buttonSize;
        button.height = sizes.buttonHeight;

        ctx.font = `${button.fontSize}px VT323, monospace`;
        const textWidth = ctx.measureText(button.text).width;
        const minWidth = sizes.breakpoint === 'xs' ? canvas.width * 0.6 : canvas.width * 0.4;
        button.width = Math.max(textWidth + sizes.buttonPadding, minWidth);
        button.y = buttonStartY + index * sizes.spacing.buttonGap;

        drawButton(button, index);
      });

      const totalAnimationTime = ANIMATION_DELAYS.buttons + ANIMATION_DURATIONS.buttons + 200;
      if (Date.now() - animationStartTime >= totalAnimationTime) {
        isAnimationComplete = true;
      }

      const frameEnd = performance.now();

      perfStats.frameCount++;
      if (frameEnd - perfStats.lastFPSCheck > 1000) {
        perfStats.currentFPS = Math.round(perfStats.frameCount * 1000 / (frameEnd - perfStats.lastFPSCheck));
        perfStats.frameCount = 0;
        perfStats.lastFPSCheck = frameEnd;

        if (perfStats.currentFPS < 40 && stars.length > 30) {
          stars = stars.slice(0, Math.max(20, stars.length * 0.7));
        }
      }
    }

    function handlePointer(e) {
      if (!isAnimationComplete) return;

      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;

      let clientX, clientY;
      if (e.touches && e.touches.length > 0) {
        clientX = e.touches[0].clientX;
        clientY = e.touches[0].clientY;
      } else if (e.changedTouches && e.changedTouches.length > 0) {
        clientX = e.changedTouches[0].clientX;
        clientY = e.changedTouches[0].clientY;
      } else {
        clientX = e.clientX;
        clientY = e.clientY;
      }

      const mouseX = (clientX - rect.left) * scaleX;
      const mouseY = (clientY - rect.top) * scaleY;

      hoveredButton = -1;

      buttons.forEach((button, index) => {
        const centerX = canvas.width / 2;
        const buttonX = centerX - button.width / 2;
        const buttonY = button.y - button.height / 2;

        if (mouseX >= buttonX && mouseX <= buttonX + button.width &&
          mouseY >= buttonY && mouseY <= buttonY + button.height) {
          hoveredButton = index;
        }
      });

      const newCursor = hoveredButton >= 0 ? 'pointer' : 'default';
      if (canvas.style.cursor !== newCursor) {
        canvas.style.cursor = newCursor;
      }
    }

    function handleClick(e) {
      if (!isAnimationComplete) return;

      e.preventDefault();
      e.stopPropagation();

      if (hoveredButton >= 0) {
        const button = buttons[hoveredButton];

        try {
          if (button.href.startsWith('http')) {
            window.open(button.href, '_blank', 'noopener,noreferrer');
          } else {
            window.location.href = button.href;
          }
        } catch (error) {
          console.warn('Navigation error:', error);
          window.location.href = button.href;
        }
      }
    }

    canvas.addEventListener('mousemove', handlePointer, { passive: true });
    canvas.addEventListener('click', handleClick);

    if (isTouch) {
      canvas.addEventListener('touchstart', (e) => {
        e.preventDefault();
        handlePointer(e);
      }, { passive: false });

      canvas.addEventListener('touchmove', (e) => {
        e.preventDefault();
        handlePointer(e);
      }, { passive: false });

      canvas.addEventListener('touchend', (e) => {
        e.preventDefault();
        handleClick(e);
      }, { passive: false });
    }

    function animate(currentTime) {
      if (!isVisible) {
        requestAnimationFrame(animate);
        return;
      }

      const adaptiveFrameInterval = perfStats.currentFPS < 45 ?
        frameInterval * 1.3 : frameInterval;

      if (currentTime - lastFrameTime >= adaptiveFrameInterval) {
        time = currentTime;
        draw();
        lastFrameTime = currentTime;
      }

      requestAnimationFrame(animate);
    }

    function initialize() {
      setupCanvas();
      animationStartTime = Date.now();
      animate(0);
    }

    window.addEventListener('error', (e) => {
      console.error('Canvas error:', e);
      document.body.classList.add('error');
    });

    Promise.all([
      loadFonts(),
      new Promise(resolve => {
        if (document.readyState === 'complete') {
          resolve();
        } else {
          window.addEventListener('load', resolve);
        }
      })
    ]).then(() => {
      setTimeout(initialize, 50);
    }).catch(error => {
      console.error('Initialization error:', error);
      document.body.classList.add('error');
    });

    if (location.hostname === 'localhost' || location.hostname === '127.0.0.1') {
      setInterval(() => {
        console.log(`FPS: ${perfStats.currentFPS}, Stars: ${stars.length}, Viewport: ${getViewportInfo().width}x${getViewportInfo().height}`);
      }, 5000);
    }
  </script>
</body>

</html>
