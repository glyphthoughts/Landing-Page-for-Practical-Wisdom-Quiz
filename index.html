<!DOCTYPE html>
<html lang="en">


<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=VT323:wght@400&display=swap" rel="stylesheet">
  <title>Practical Wisdom</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      user-select: none;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
    }

    html,
    body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      touch-action: none;
    }

    body {
      background: #000;
      font-family: "VT323", monospace;
      cursor: default;
      position: fixed;
      top: 0;
      left: 0;
    }

    canvas {
      display: block;
      background: #000;
      cursor: pointer;
      width: 100vw;
      height: 100vh;
      position: absolute;
      top: 0;
      left: 0;
    }

    @media (max-width: 480px) and (orientation: portrait) {
      canvas {
        width: 100vw;
        height: 100vh;
      }
    }

    @media (max-height: 600px) and (orientation: landscape) {
      canvas {
        width: 100vw;
        height: 100vh;
      }
    }
  </style>
</head>


<body>
  <canvas id="canvas"></canvas>


  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    let devicePixelRatio = window.devicePixelRatio || 1;
    let isTouch = 'ontouchstart' in window;

    function drawRoundedRect(x, y, width, height, radius) {
      ctx.beginPath();
      ctx.moveTo(x + radius, y);
      ctx.lineTo(x + width - radius, y);
      ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
      ctx.lineTo(x + width, y + height - radius);
      ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
      ctx.lineTo(x + radius, y + height);
      ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
      ctx.lineTo(x, y + radius);
      ctx.quadraticCurveTo(x, y, x + radius, y);
      ctx.closePath();
    }

    function getResponsiveSizes() {
      const baseWidth = Math.min(canvas.width, 1920);
      const baseHeight = Math.min(canvas.height, 1080);
      const isSmallScreen = canvas.width < 768;
      const isVerySmallScreen = canvas.width < 480;
      const isTinyHeight = canvas.height < 600;
      const isLandscape = canvas.width > canvas.height;
      const aspectRatio = canvas.width / canvas.height;

      let scaleFactor;
      if (isVerySmallScreen || (isTinyHeight && isLandscape)) {
        scaleFactor = Math.min(baseWidth / 1920, baseHeight / 1080) * 0.6;
      } else if (isSmallScreen) {
        scaleFactor = Math.min(baseWidth / 1920, baseHeight / 1080) * 0.75;
      } else {
        scaleFactor = Math.min(baseWidth / 1920, baseHeight / 1080);
      }

      return {
        titleSize: Math.max(Math.min(80 * scaleFactor, baseWidth * 0.06), 24),
        subtitleSize: Math.max(Math.min(42 * scaleFactor, baseWidth * 0.032), 18),
        taglineSize: Math.max(Math.min(32 * scaleFactor, baseWidth * 0.025), 16),
        paragraphSize: Math.max(Math.min(26 * scaleFactor, baseWidth * 0.022), 14),
        buttonSize: Math.max(Math.min(28 * scaleFactor, baseWidth * 0.024), 16),
        buttonHeight: Math.max(Math.min(50 * scaleFactor, baseHeight * 0.055), 40),
        buttonPadding: Math.max(Math.min(40 * scaleFactor, baseWidth * 0.035), 20),
        paragraphWidth: Math.min(baseWidth * 0.85, 900),
        spacing: {
          title: isVerySmallScreen ? 0.18 : (isSmallScreen ? 0.22 : 0.25),
          subtitle: isVerySmallScreen ? 0.10 : (isSmallScreen ? 0.12 : 0.14),
          tagline: isVerySmallScreen ? 0.06 : (isSmallScreen ? 0.075 : 0.09),
          paragraph: isVerySmallScreen ? -0.02 : (isSmallScreen ? 0.02 : 0.04),
          buttons: isVerySmallScreen ? 0.12 : (isSmallScreen ? 0.15 : 0.18),
          buttonGap: Math.max(baseHeight * 0.07, 35)
        },
        isSmallScreen,
        isVerySmallScreen,
        isTinyHeight,
        scaleFactor
      };
    }

    function resizeCanvas() {
      const displayWidth = window.innerWidth;
      const displayHeight = window.innerHeight;

      if (canvas.width !== displayWidth * devicePixelRatio ||
        canvas.height !== displayHeight * devicePixelRatio) {

        canvas.width = displayWidth * devicePixelRatio;
        canvas.height = displayHeight * devicePixelRatio;

        canvas.style.width = displayWidth + 'px';
        canvas.style.height = displayHeight + 'px';

        ctx.scale(devicePixelRatio, devicePixelRatio);

        canvas.width = displayWidth;
        canvas.height = displayHeight;
      }

      initStars();
      draw();
    }

    window.addEventListener('resize', () => {
      setTimeout(resizeCanvas, 100);
    });

    window.addEventListener('orientationchange', () => {
      setTimeout(resizeCanvas, 300);
    });

    let stars = [];

    function initStars() {
      const sizes = getResponsiveSizes();
      const numStars = sizes.isVerySmallScreen ? 120 : (sizes.isSmallScreen ? 150 : 180);

      stars = [];
      for (let i = 0; i < numStars; i++) {
        stars.push({
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height,
          size: (sizes.isVerySmallScreen ? 1.5 : 2) + Math.random() * (sizes.isVerySmallScreen ? 1.5 : 2.5),
          opacity: 0.3 + Math.random() * 0.6,
          twinkleSpeed: 2 + Math.random() * 3,
          phase: Math.random() * Math.PI * 2
        });
      }
    }

    const buttons = [
      {
        text: "Take the quiz",
        y: 0,
        width: 0,
        height: 0,
        fontSize: 0,
        isPrimary: true,
        href: "quiz.html"
      },
      {
        text: "GlyphThoughts Website",
        y: 0,
        width: 0,
        height: 0,
        fontSize: 0,
        isPrimary: false,
        href: "https://glyphthoughts.carrd.co"
      }
    ];

    let hoveredButton = -1;
    let time = 0;
    let fontsLoaded = false;

    function loadFonts() {
      return new Promise((resolve) => {
        if (document.fonts) {
          document.fonts.load('400 20px VT323').then(() => {
            fontsLoaded = true;
            resolve();
          }).catch(() => {
            setTimeout(() => {
              fontsLoaded = true;
              resolve();
            }, 2000);
          });
        } else {
          setTimeout(() => {
            fontsLoaded = true;
            resolve();
          }, 2000);
        }
      });
    }

    function drawStars() {
      stars.forEach(star => {
        const twinkle = 0.2 + 0.8 * (0.5 + 0.5 * Math.sin(time * 0.001 * star.twinkleSpeed + star.phase));
        ctx.fillStyle = `rgba(255, 255, 255, ${star.opacity * twinkle})`;
        ctx.beginPath();
        ctx.arc(star.x, star.y, star.size * twinkle, 0, Math.PI * 2);
        ctx.fill();
      });
    }

    function drawText(text, x, y, fontSize, color = '#EAEAEA', align = 'center', maxWidth = null, forceLines = null) {
      ctx.font = `${fontSize}px VT323, monospace`;
      ctx.fillStyle = color;
      ctx.textAlign = align;
      ctx.textBaseline = 'middle';

      if (maxWidth) {
        const words = text.split(' ');
        let lines = [];

        if (forceLines) {
          const sizes = getResponsiveSizes();
          const targetLines = sizes.isVerySmallScreen ? Math.min(forceLines + 1, 5) : forceLines;
          let targetLinesWidth = maxWidth;
          let attempts = 0;

          while (attempts < 25) {
            lines = [];
            let currentLine = '';

            for (let word of words) {
              const testLine = currentLine + (currentLine ? ' ' : '') + word;
              const metrics = ctx.measureText(testLine);
              if (metrics.width > targetLinesWidth && currentLine) {
                lines.push(currentLine);
                currentLine = word;
              } else {
                currentLine = testLine;
              }
            }
            if (currentLine) lines.push(currentLine);

            if (lines.length === targetLines) {
              break;
            } else if (lines.length > targetLines) {
              targetLinesWidth += 15;
            } else {
              targetLinesWidth -= 10;
            }
            attempts++;
          }
        } else {
          let currentLine = '';
          for (let word of words) {
            const testLine = currentLine + (currentLine ? ' ' : '') + word;
            const metrics = ctx.measureText(testLine);
            if (metrics.width > maxWidth && currentLine) {
              lines.push(currentLine);
              currentLine = word;
            } else {
              currentLine = testLine;
            }
          }
          if (currentLine) lines.push(currentLine);
        }

        const lineHeight = fontSize * (getResponsiveSizes().isVerySmallScreen ? 1.3 : 1.4);
        const startY = y - ((lines.length - 1) * lineHeight) / 2;
        lines.forEach((line, i) => {
          ctx.fillText(line, x, startY + i * lineHeight);
        });

        return lines.length * lineHeight;
      } else {
        ctx.fillText(text, x, y);
        return fontSize;
      }
    }

    function drawButton(button, index) {
      const isHovered = hoveredButton === index;
      const centerX = canvas.width / 2;
      const sizes = getResponsiveSizes();

      const alpha = isHovered ? (sizes.isSmallScreen ? 0.15 : 0.12) : (sizes.isSmallScreen ? 0.08 : 0.06);
      ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
      ctx.strokeStyle = button.isPrimary ?
        `rgba(255, 255, 255, ${sizes.isSmallScreen ? 0.4 : 0.3})` :
        `rgba(255, 255, 255, ${sizes.isSmallScreen ? 0.3 : 0.2})`;
      ctx.lineWidth = sizes.isVerySmallScreen ? 1 : 1.25;

      const buttonX = centerX - button.width / 2;
      const buttonY = button.y - button.height / 2;

      const radius = Math.min(10, button.height * 0.2);
      drawRoundedRect(buttonX, buttonY, button.width, button.height, radius);
      ctx.fill();
      ctx.stroke();

      ctx.fillStyle = '#EAEAEA';
      ctx.font = `${button.fontSize}px VT323, monospace`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(button.text, centerX, button.y);
    }

    function draw() {
      if (!fontsLoaded) return;

      ctx.fillStyle = '#000000';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      drawStars();

      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      const sizes = getResponsiveSizes();

      const titleY = centerY - (canvas.height * sizes.spacing.title);
      const subtitleY = centerY - (canvas.height * sizes.spacing.subtitle);
      const taglineY = centerY - (canvas.height * sizes.spacing.tagline);
      const paragraphY = centerY + (canvas.height * sizes.spacing.paragraph);

      drawText("Practical Wisdom", centerX, titleY, sizes.titleSize, '#EAEAEA');
      drawText("The Stoic Mindset", centerX, subtitleY, sizes.subtitleSize, '#BDBDBD');
      drawText("'Introspection Exercise'", centerX, taglineY, sizes.taglineSize, '#BDBDBD');

      const aboutText = "Ten prompt‑based questions completed in about 3–5 minutes; no grading and no leaderboards—only reflection over comparison. The language and tone are shaped by Stoic practice: restraint, judgment, purpose. On completion, an optional certificate acknowledges the identified mindset; it is not a qualification.";
      const targetLines = sizes.isVerySmallScreen ? 5 : 4;
      drawText(aboutText, centerX, paragraphY, sizes.paragraphSize, '#FFFFFF', 'center', sizes.paragraphWidth, targetLines);

      const buttonStartY = centerY + (canvas.height * sizes.spacing.buttons);

      buttons.forEach((button, index) => {
        button.fontSize = sizes.buttonSize;
        button.height = sizes.buttonHeight;

        ctx.font = `${button.fontSize}px VT323, monospace`;
        const textWidth = ctx.measureText(button.text).width;
        button.width = Math.max(textWidth + sizes.buttonPadding, canvas.width * 0.3);
        button.y = buttonStartY + index * sizes.spacing.buttonGap;

        drawButton(button, index);
      });
    }

    function handlePointer(e) {
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;

      const clientX = e.clientX || (e.touches && e.touches[0] ? e.touches[0].clientX : 0);
      const clientY = e.clientY || (e.touches && e.touches[0] ? e.touches[0].clientY : 0);

      const mouseX = (clientX - rect.left) * scaleX;
      const mouseY = (clientY - rect.top) * scaleY;

      hoveredButton = -1;

      buttons.forEach((button, index) => {
        const centerX = canvas.width / 2;
        const buttonX = centerX - button.width / 2;
        const buttonY = button.y - button.height / 2;

        if (mouseX >= buttonX && mouseX <= buttonX + button.width &&
          mouseY >= buttonY && mouseY <= buttonY + button.height) {
          hoveredButton = index;
        }
      });

      canvas.style.cursor = hoveredButton >= 0 ? 'pointer' : 'default';
    }

    function handleClick(e) {
      e.preventDefault();
      if (hoveredButton >= 0) {
        const button = buttons[hoveredButton];
        if (button.href.startsWith('http')) {
          window.open(button.href, '_blank');
        } else {
          window.location.href = button.href;
        }
      }
    }

    canvas.addEventListener('mousemove', handlePointer);
    canvas.addEventListener('click', handleClick);

    if (isTouch) {
      canvas.addEventListener('touchstart', (e) => {
        e.preventDefault();
        handlePointer(e);
      }, { passive: false });

      canvas.addEventListener('touchmove', (e) => {
        e.preventDefault();
        handlePointer(e);
      }, { passive: false });

      canvas.addEventListener('touchend', (e) => {
        e.preventDefault();
        handleClick(e);
      }, { passive: false });
    }

    function animate() {
      time = Date.now();
      draw();
      requestAnimationFrame(animate);
    }

    loadFonts().then(() => {
      resizeCanvas();
      animate();
    });

    window.addEventListener('load', () => {
      setTimeout(resizeCanvas, 100);
    });
  </script>
</body>


</html>
